use std::io::{self, Write};
/* 
 Rustの標準ライブラリ(std:Standard Library)からioモジュールをインポート
 ioモジュールは、入出力操作を行うための機能を提供します。
 Writeトレイトは、データを書き込むためのメソッドを提供します。
 通常stdはデフォルトでインポートされてるので省略できる。
 しかし、今回はioモジュールを明示的にインポートしている。慣れのためである。
*/

fn main() {
    println!("ヒットアンドブロー");
    println!("Hit and Blow");
    println!("---------------------");
    // : &'static strは文字列リテラルを示す型
    let game_rules = "
        ルール
        1. 4桁の数字を当てるゲームです。
        2. 各桁は1から6までの数字で、同じ数字は使いません。
        3. ユーザーが入力した数字と正解の数字を比較し、ヒットとブローを教えます。
        4. ヒットは正しい位置にある数字、ブローは正しい数字だが位置が違うものです。
        5. ゲームは10回まで続きます。
    ";
    
    println!("{}", game_rules);
    
    // 無限ループの開始
    loop {
        // ゲームのロジックをここに追加
        print!("ゲームを開始します...\n");
        //ゲームの関数がここに入る
        print!("正解です！");
        print!("続けますか？ (y/n): ");
        /* バッファをフラッシュして即座に表示
        標準出力に書き込まれたデータを即座に表示するためにflush()メソッドを使用
        これをやらないと、バッファリングのために出力が遅れることがある
         */
        io::stdout().flush().unwrap(); 
        
        // ユーザーからの入力を受け取る
        let mut input = String::new(); // 入力用の文字列を初期化
        io::stdin().read_line(&mut input).unwrap(); // 標準入力から1行読み込む
        
        // 入力を小文字にして、trimで空白を削除
        let input = input.trim().to_lowercase(); 

        /* letとlet mutの違いは
        letは不変な変数(immutable)を定義するために使用される。定数のようなもの。
        let mutは可変な変数(mutable)を定義するために使用される。
         */
        /* 変数名の後ろの : Stringについて
        型アノテーション(type annotation)は、変数の型を明示的に指定するためのもの。
        付けないことも可能だが、型を明示することでコードの可読性が向上する。
        どちらかと言えば、人間用かも。
         */
        
        // 'n'が入力された場合のみループを抜ける
        if input == "n" {
            println!("ゲームを終了します。");
            break;// ループを抜ける
        } else {
            println!("ゲームを続けます...");
        }
    }
    // ゲーム終了後のメッセージ
    println!("ゲームが終了しました。");
}
